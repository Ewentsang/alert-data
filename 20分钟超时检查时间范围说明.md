# 20分钟超时检查时间范围说明

## 时间范围计算逻辑

### 场景说明

假设有一个"告警触发"记录：
- **告警触发时间**：`2025-12-11 10:00:00`（这是 `alert.time` 字段的值）

### 20分钟时间窗口

**开始时间（check_start_time）**：
- 就是告警触发的时间：`2025-12-11 10:00:00`
- 代码：`check_start_time = alert.time`

**结束时间（check_end_time）**：
- 告警触发时间 + 20分钟：`2025-12-11 10:20:00`
- 代码：`check_end_time = check_start_time + timedelta(minutes=ALERT_TIMEOUT_MINUTES)`

### 时间窗口图示

```
告警触发时间              20分钟后
    |                      |
    |<---- 20分钟窗口 ----->|
    |                      |
10:00:00              10:20:00
  ↑                      ↑
开始时间              结束时间
```

## 两种检查机制

### 机制 1：异步任务检查（单个告警）

**函数**：`check_timeout_for_alert(alert_id)`

**工作流程**：
1. 收到"告警触发"时，立即启动一个异步任务
2. 任务等待 20 分钟：`await asyncio.sleep(ALERT_TIMEOUT_MINUTES * 60)`
3. 20 分钟后，检查是否有"告警恢复"：
   - **开始时间**：`alert.time`（告警触发时间）
   - **结束时间**：`alert.time + 20分钟`
   - **检查范围**：在这 20 分钟内是否有匹配的"告警恢复"

**代码逻辑**：
```python
# 开始时间
check_start_time = alert.time  # 例如：2025-12-11 10:00:00

# 结束时间
check_end_time = alert.time + timedelta(minutes=20)  # 例如：2025-12-11 10:20:00

# 检查是否有"告警恢复"在这个时间范围内
recent_recovery = db.query(Alert).filter(
    Alert.time > check_start_time,   # 恢复时间 > 10:00:00
    Alert.time <= check_end_time     # 恢复时间 <= 10:20:00
).first()
```

### 机制 2：定期检查（所有告警）

**函数**：`check_timeout_alerts_periodically()`

**工作流程**：
1. 每 60 秒运行一次（可配置）
2. 查找所有超过 20 分钟的"告警触发"记录：
   - **当前时间**：`datetime.now()`（例如：`2025-12-11 10:30:00`）
   - **截止时间**：`当前时间 - 20分钟`（例如：`2025-12-11 10:10:00`）
   - **查询条件**：`alert.time <= 截止时间`（找到所有超过 20 分钟的告警）
3. 对每条记录，检查是否有"告警恢复"：
   - **开始时间**：`alert.time`（告警触发时间）
   - **结束时间**：`alert.time + 20分钟`
   - **检查范围**：在这 20 分钟内是否有匹配的"告警恢复"

**代码逻辑**：
```python
# 当前时间
now = datetime.now(beijing_tz)  # 例如：2025-12-11 10:30:00

# 截止时间（用于查找超过20分钟的告警）
cutoff_time = now - timedelta(minutes=20)  # 例如：2025-12-11 10:10:00

# 查找所有超过20分钟的告警
timeout_alerts = db.query(Alert).filter(
    Alert.time <= cutoff_time  # 告警时间 <= 10:10:00（即超过20分钟）
).all()

# 对每条告警，检查20分钟窗口内是否有恢复
for alert in timeout_alerts:
    check_start_time = alert.time  # 例如：10:00:00
    check_end_time = alert.time + timedelta(minutes=20)  # 例如：10:20:00
    
    # 检查 10:00:00 到 10:20:00 之间是否有"告警恢复"
    recent_recovery = db.query(Alert).filter(
        Alert.time > check_start_time,   # > 10:00:00
        Alert.time <= check_end_time     # <= 10:20:00
    ).first()
```

## 具体示例

### 示例 1：正常情况

**时间线**：
- `10:00:00` - 收到"告警触发"
- `10:15:00` - 收到"告警恢复"（在 20 分钟内）
- `10:20:00` - 20 分钟窗口结束

**结果**：
- ✅ 在 20 分钟窗口内找到了"告警恢复"
- ✅ 不会触发超时通知
- ✅ `processed = True`（标记为已处理）

### 示例 2：超时情况

**时间线**：
- `10:00:00` - 收到"告警触发"
- `10:20:00` - 20 分钟窗口结束（没有收到"告警恢复"）
- `10:21:00` - 定期检查运行，发现超时

**结果**：
- ❌ 在 20 分钟窗口内没有找到"告警恢复"
- ✅ 触发超时通知
- ✅ `timeout_triggered = True`

### 示例 3：定期检查的时间点

**假设当前时间**：`10:30:00`

**查找条件**：
- `cutoff_time = 10:30:00 - 20分钟 = 10:10:00`
- 查找所有 `alert.time <= 10:10:00` 的告警

**找到的告警**：
- `10:00:00` 的告警 ✅（超过 20 分钟）
- `10:05:00` 的告警 ✅（超过 20 分钟）
- `10:15:00` 的告警 ❌（未超过 20 分钟，不检查）

**对 `10:00:00` 的告警检查**：
- 开始时间：`10:00:00`
- 结束时间：`10:20:00`
- 检查 `10:00:00` 到 `10:20:00` 之间是否有"告警恢复"

## 关键点总结

1. **开始时间**：始终是告警触发的时间（`alert.time`）
2. **结束时间**：告警触发时间 + 20 分钟
3. **检查范围**：从告警触发时间开始，往后 20 分钟的时间窗口
4. **定期检查**：查找所有超过 20 分钟的告警，然后对每条告警检查其 20 分钟窗口

## 时间范围图示

```
告警触发时间（开始时间）          结束时间（开始时间 + 20分钟）
        |                              |
        |<-------- 20分钟窗口 --------->|
        |                              |
    10:00:00                      10:20:00
        |                              |
        |                              |
    在这个时间范围内查找"告警恢复"
    如果找到 → 不触发超时
    如果没找到 → 触发超时
```

## 代码中的关键部分

```python
# 1. 确定开始时间（告警触发时间）
check_start_time = alert.time

# 2. 确定结束时间（开始时间 + 20分钟）
check_end_time = check_start_time + timedelta(minutes=ALERT_TIMEOUT_MINUTES)

# 3. 检查这个时间范围内是否有"告警恢复"
recent_recovery = db.query(Alert).filter(
    Alert.time > check_start_time,   # 恢复时间必须晚于告警触发时间
    Alert.time <= check_end_time     # 恢复时间必须在20分钟内
).first()
```


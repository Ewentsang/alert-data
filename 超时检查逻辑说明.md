# 超时检查逻辑说明

## 概述

本文档说明定期检查超时告警的新逻辑。系统会定期检查所有未处理的"告警触发"记录，判断是否在指定时间窗口内收到了对应的"告警恢复"，如果没有则触发 Dify 工作流。

## 核心逻辑

### 1. 筛选条件

**查找所有符合条件的"告警触发"记录：**

- `om_type == "告警触发"`
- `processed == False`（未收到告警恢复）
- `timeout_triggered == False`（未触发超时通知）

**注意：** 不再使用 `time <= cutoff_time` 进行筛选，而是检查**所有未处理的告警**。

### 2. 对每条告警的检查流程

对于每条符合条件的告警，执行以下检查：

#### 2.1 确定检查窗口

- **开始时间** = 该告警的 `time` 字段（数据库中存储的告警发生时间）
- **结束时间** = `time + ALERT_TIMEOUT_MINUTES`（当前配置为 10 秒，即 0.167 分钟）
- **检查窗口** = `[time, time + ALERT_TIMEOUT_MINUTES]`

#### 2.2 检查是否有对应的"告警恢复"

在检查窗口内查找是否有匹配的"告警恢复"记录：

**匹配条件：**
- `om_type == "告警恢复"`
- `enterprise_name == 告警触发.enterprise_name`（相同企业）
- `alert_key == 告警触发.alert_key`（相同告警键）
- `time >= 告警触发.time`（恢复时间晚于或等于触发时间）
- `time <= 告警触发.time + ALERT_TIMEOUT_MINUTES`（恢复时间在检查窗口内）

#### 2.3 超时判断

**判断条件：**
- 当前时间 > `time + ALERT_TIMEOUT_MINUTES`（检查窗口已过期）
- 且检查窗口内**没有**找到匹配的"告警恢复"

**如果满足超时条件：**
1. 调用 Dify 工作流，发送超时通知
2. 设置 `timeout_triggered = True`
3. 保持 `processed = False`

**如果找到"告警恢复"：**
- 在收到"告警恢复"时，会立即将匹配的"告警触发"记录的 `processed` 设置为 `True`
- 这样在定期检查时就不会再检查这些已处理的告警

## 时间线示例

### 示例 1：正常恢复（不触发超时）

```
时间轴：
15:18:20  ← 告警触发（time = 15:18:20）
          ↓
          [检查窗口: 15:18:20 ~ 15:18:30]
          ↓
15:18:25  ← 告警恢复（在窗口内）
          ↓
          processed = True（由 receive_alert 端点设置）
          ↓
15:18:36  ← 定期检查（不检查此告警，因为 processed = True）
```

### 示例 2：超时触发

```
时间轴：
15:18:20  ← 告警触发（time = 15:18:20）
          ↓
          [检查窗口: 15:18:20 ~ 15:18:30]
          ↓
15:18:30  ← 窗口结束，未收到告警恢复
          ↓
15:18:36  ← 定期检查
          - 当前时间 (15:18:36) > 结束时间 (15:18:30) ✓
          - 窗口内没有"告警恢复" ✓
          - 触发 Dify 工作流
          - timeout_triggered = True
```

### 示例 3：窗口未过期（不触发）

```
时间轴：
15:18:27  ← 告警触发（time = 15:18:27）
          ↓
          [检查窗口: 15:18:27 ~ 15:18:37]
          ↓
15:18:36  ← 定期检查
          - 当前时间 (15:18:36) < 结束时间 (15:18:37) ✗
          - 窗口未过期，不触发
          ↓
15:18:37  ← 窗口结束
          ↓
15:18:39  ← 下次定期检查
          - 当前时间 (15:18:39) > 结束时间 (15:18:37) ✓
          - 窗口内没有"告警恢复" ✓
          - 触发 Dify 工作流
```

## 日志输出

### 定期检查开始日志

每次定期检查开始时，输出检查窗口信息：

```
[定期检查] 开始检查超时告警 - 
  检查窗口开始时间: 2025-12-11 15:18:26, 
  检查窗口结束时间: 2025-12-11 15:18:36, 
  间隔时间: 10.0秒 (超过0.167分钟)
```

**注意：** 这个日志显示的是**全局检查窗口**（用于筛选可能超时的告警），但实际检查时，每条告警使用自己的 `time` 字段作为开始时间。

### 每条告警的检查日志

对于每条被检查的告警，输出详细信息：

```
[定期检查] 检查告警 ID=1: 
  告警时间=2025-12-11 15:18:20, 
  检查窗口开始=15:18:20, 
  检查窗口结束=15:18:30, 
  间隔时间=10.0秒, 
  已过去=0.XX分钟, 
  企业=XXX, 
  alert_key=XXX
```

### 超时触发日志

当触发 Dify 工作流时，输出：

```
[触发超时] 告警 ID=1 超时，触发 Dify 工作流
[触发超时] Dify 响应: 200 OK
```

## 关键区别

| 项目 | 旧逻辑 | 新逻辑 |
|------|--------|--------|
| **筛选方式** | 使用 `time <= cutoff_time` 筛选 | 检查所有 `processed=False` 且 `timeout_triggered=False` 的告警 |
| **检查窗口** | 全局窗口：`[now - 10秒, now]` | 每条告警独立窗口：`[time, time + 10秒]` |
| **触发条件** | 告警时间在截止时间之前 | 当前时间超过告警的检查窗口结束时间 |
| **灵活性** | 所有告警使用同一个时间窗口 | 每条告警有自己的时间窗口 |

## 配置参数

- **`ALERT_TIMEOUT_MINUTES`**: 超时时间（分钟），当前配置为 `0.167`（10秒）
- **`CHECK_INTERVAL_SECONDS`**: 定期检查间隔（秒），当前配置为 `2` 秒

## 状态字段说明

### `processed` 字段

- **`False`**: 未收到匹配的"告警恢复"，需要继续监控
- **`True`**: 已收到匹配的"告警恢复"，超时通知被取消

### `timeout_triggered` 字段

- **`False`**: 未触发超时通知
- **`True`**: 已触发超时通知（检查窗口内未收到"告警恢复"）

### 状态组合

| processed | timeout_triggered | 含义 |
|-----------|------------------|------|
| `False` | `False` | 正常监控中，等待恢复或超时 |
| `True` | `False` | 已收到"告警恢复"，取消超时 |
| `False` | `True` | 已触发超时通知 |
| `True` | `True` | 理论上不应该出现此状态 |

## 注意事项

1. **时区处理**：所有时间都使用北京时间（UTC+8）
2. **时间精度**：`time` 字段精确到秒
3. **并发处理**：定期检查和接收"告警恢复"可能并发执行，通过数据库事务保证一致性
4. **性能考虑**：如果未处理的告警数量很大，可能需要优化查询和索引

## 相关文件

- `main.py`: 主要逻辑实现
- `database.py`: 数据库模型定义
- `config.py`: 配置参数
- `parser.py`: 时间解析函数


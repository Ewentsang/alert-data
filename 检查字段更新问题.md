# 检查 processed 和 timeout_triggered 字段未更新的原因

## 可能的原因

### 1. 服务未重启
**问题**：代码已修改，但服务还在运行旧代码

**解决方案**：
```bash
# 重启后端服务
docker-compose restart backend

# 或完全重建
docker-compose down
docker-compose up -d --build
```

### 2. 这些是旧的记录
**问题**：这些记录是在代码修改之前创建的，字段值已经是 `False`

**说明**：
- `processed = False` 和 `timeout_triggered = False` 是默认值
- 这些字段只有在特定条件下才会被更新为 `True`

### 3. 触发条件未满足

#### `processed` 字段更新为 `True` 的条件：
- 必须是"告警触发"类型的记录
- 收到了匹配的"告警恢复"（同 `enterprise_name` 和 `alert_key`）
- 告警恢复的时间必须晚于告警触发的时间

#### `timeout_triggered` 字段更新为 `True` 的条件：
- 必须是"告警触发"类型的记录
- 20分钟内没有收到匹配的"告警恢复"
- 超时后触发通知

## 检查步骤

### 步骤 1：确认服务已重启

```bash
# 查看服务状态
docker-compose ps

# 查看日志，确认新代码已加载
docker-compose logs backend | tail -20
```

### 步骤 2：检查记录类型

在数据库中执行：
```sql
-- 查看这些记录的详细信息
SELECT 
    id,
    alert_type,
    enterprise_name,
    alert_key,
    processed,
    timeout_triggered,
    time,
    created_at
FROM alerts
WHERE alert_key = '企业 SHEIN 的420错误率超过阈值'
ORDER BY created_at DESC;
```

### 步骤 3：检查是否有匹配的"告警恢复"

```sql
-- 检查是否有匹配的告警恢复
SELECT 
    id,
    alert_type,
    enterprise_name,
    alert_key,
    time
FROM alerts
WHERE alert_type = '告警恢复'
  AND enterprise_name = 'SHEIN'  -- 替换为实际的企业名称
  AND alert_key = '企业 SHEIN 的420错误率超过阈值';
```

### 步骤 4：手动测试

#### 测试收到"告警恢复"时更新 `processed` 字段：

1. 发送一个"告警触发"：
```bash
curl -X POST "http://localhost:8000/api/alert" \
  -H "Content-Type: application/json" \
  -d '{
    "input": "测试告警",
    "enterprise_name": "SHEIN",
    "time": "2025-12-11 14:00:00",
    "alert_type": "告警触发",
    "template_name": "测试模板",
    "om_type": "ErrorRate",
    "alert_key": "企业 SHEIN 的420错误率超过阈值"
  }'
```

2. 立即发送一个匹配的"告警恢复"：
```bash
curl -X POST "http://localhost:8000/api/alert" \
  -H "Content-Type: application/json" \
  -d '{
    "input": "告警恢复",
    "enterprise_name": "SHEIN",
    "time": "2025-12-11 14:01:00",
    "alert_type": "告警恢复",
    "template_name": "测试模板",
    "om_type": "ErrorRate",
    "alert_key": "企业 SHEIN 的420错误率超过阈值"
  }'
```

3. 查询数据库，检查 `processed` 字段是否更新为 `True`

#### 测试超时触发更新 `timeout_triggered` 字段：

1. 修改 `.env` 文件，将超时时间改为 1 分钟（方便测试）：
```env
ALERT_TIMEOUT_MINUTES=1
```

2. 重启服务：
```bash
docker-compose restart backend
```

3. 发送一个"告警触发"：
```bash
curl -X POST "http://localhost:8000/api/alert" \
  -H "Content-Type: application/json" \
  -d '{
    "input": "测试告警",
    "enterprise_name": "SHEIN",
    "time": "2025-12-11 14:00:00",
    "alert_type": "告警触发",
    "template_name": "测试模板",
    "om_type": "ErrorRate",
    "alert_key": "企业 SHEIN 的420错误率超过阈值_测试"
  }'
```

4. 等待 1 分钟后，查询数据库，检查 `timeout_triggered` 字段是否更新为 `True`

## 查看日志

查看服务日志，确认逻辑是否执行：

```bash
# 查看实时日志
docker-compose logs -f backend

# 查看最近的日志
docker-compose logs backend | tail -50

# 搜索相关日志
docker-compose logs backend | grep "告警恢复\|超时\|processed\|timeout_triggered"
```

## 常见问题

### Q1: 为什么旧记录的字段没有更新？

**A**: 旧记录是在代码修改之前创建的，它们的字段值已经是 `False`。这些字段只有在满足特定条件时才会被更新：
- `processed`：收到匹配的"告警恢复"时
- `timeout_triggered`：超时触发通知时

### Q2: 如何更新旧记录？

如果需要手动更新旧记录的状态，可以在数据库中执行：

```sql
-- 查找已超时的告警（超过20分钟且未收到告警恢复）
UPDATE alerts
SET timeout_triggered = true
WHERE alert_type = '告警触发'
  AND processed = false
  AND timeout_triggered = false
  AND time < NOW() - INTERVAL '20 minutes';
```

### Q3: 字段显示为 `[]` 是什么意思？

**A**: `[]` 通常表示 `False` 或 `NULL`。在数据库中，布尔类型的 `False` 值可能显示为空。

## 验证代码逻辑

确认代码中的更新逻辑：

1. **收到"告警恢复"时**：
   - 查找匹配的"告警触发"（同 `enterprise_name` 和 `alert_key`）
   - 将 `processed` 设置为 `True`

2. **超时触发时**：
   - 检查是否有匹配的"告警恢复"
   - 如果没有，将 `timeout_triggered` 设置为 `True`


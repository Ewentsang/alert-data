# 定时删除数据方案对比（不修改代码）

## 方案1：PostgreSQL pg_cron 扩展 ⭐⭐⭐⭐⭐（推荐）

### 优点
- ✅ 直接在数据库层面执行，不依赖应用代码
- ✅ 即使应用重启也不受影响
- ✅ 性能好，直接在数据库内执行
- ✅ 支持复杂的 SQL 逻辑

### 缺点
- ⚠️ 需要安装 pg_cron 扩展
- ⚠️ 需要修改 docker-compose.yml（添加扩展）

### 实施步骤

#### 1. 修改 docker-compose.yml，添加 pg_cron 支持

```yaml
postgres:
  image: postgres:15-alpine
  # 改为支持扩展的镜像，或使用自定义镜像
  # 或者使用 pg_cron 官方镜像
  command: postgres -c shared_preload_libraries=pg_cron -c cron.database_name=alert_db
  # ... 其他配置保持不变
```

或者使用包含 pg_cron 的镜像：
```yaml
postgres:
  image: citusdata/postgres:15-alpine  # 包含 pg_cron
  # 或使用自定义 Dockerfile
```

#### 2. 在数据库中启用扩展

```sql
-- 连接到数据库
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- 创建定时任务：每天 00:00:05 执行删除
SELECT cron.schedule(
    'delete-old-alerts',           -- 任务名称
    '5 0 * * *',                    -- cron 表达式：每天 00:00:05（北京时间）
    $$                              -- SQL 语句
    DELETE FROM alerts 
    WHERE time < (
        SELECT (CURRENT_DATE AT TIME ZONE 'Asia/Shanghai')::timestamp
    )
    AND NOT (
        time >= (CURRENT_DATE AT TIME ZONE 'Asia/Shanghai')::timestamp - INTERVAL '25 minutes'
        AND time < (CURRENT_DATE AT TIME ZONE 'Asia/Shanghai')::timestamp
        AND timeout_triggered = false
        AND processed = false
    );
    $$
);
```

#### 3. 查看和管理任务

```sql
-- 查看所有定时任务
SELECT * FROM cron.job;

-- 查看任务执行历史
SELECT * FROM cron.job_run_details ORDER BY start_time DESC LIMIT 10;

-- 删除任务
SELECT cron.unschedule('delete-old-alerts');

-- 修改任务（先删除再创建）
```

### 注意事项
- pg_cron 需要 PostgreSQL 9.5+
- 需要 superuser 权限来创建扩展
- cron 表达式使用 UTC 时间，需要根据时区调整

---

## 方案2：系统级 Cron 任务 ⭐⭐⭐⭐

### 优点
- ✅ 不依赖数据库扩展
- ✅ 简单直接
- ✅ 可以执行任何命令（SQL、API 调用等）

### 缺点
- ⚠️ 需要在服务器上配置
- ⚠️ 需要能访问数据库

### 实施步骤

#### 1. 创建删除脚本 `delete_old_alerts.sh`

```bash
#!/bin/bash
# 设置时区
export TZ=Asia/Shanghai

# 执行删除 SQL
docker-compose exec -T postgres psql -U alert_user -d alert_db <<EOF
DELETE FROM alerts 
WHERE time < (CURRENT_DATE AT TIME ZONE 'Asia/Shanghai')::timestamp
AND NOT (
    time >= (CURRENT_DATE AT TIME ZONE 'Asia/Shanghai')::timestamp - INTERVAL '25 minutes'
    AND time < (CURRENT_DATE AT TIME ZONE 'Asia/Shanghai')::timestamp
    AND timeout_triggered = false
    AND processed = false
);
EOF
```

#### 2. 添加到 crontab

```bash
# 编辑 crontab
crontab -e

# 添加任务（每天 00:00:05 执行，北京时间）
5 0 * * * /path/to/delete_old_alerts.sh >> /var/log/delete_alerts.log 2>&1

# 或者使用绝对路径的 docker-compose
5 0 * * * cd /path/to/alert_database && docker-compose exec -T postgres psql -U alert_user -d alert_db -c "DELETE FROM alerts WHERE ..."
```

#### 3. 验证

```bash
# 查看 crontab
crontab -l

# 查看日志
tail -f /var/log/delete_alerts.log
```

---

## 方案3：Dify 定时触发工作流 ⭐⭐⭐

### 优点
- ✅ 可以利用现有的 Dify 平台
- ✅ 可以添加更复杂的逻辑（通知、日志等）
- ✅ 可视化配置

### 缺点
- ⚠️ 需要调用 API，需要网络
- ⚠️ 需要配置 HTTP 请求节点
- ⚠️ 依赖 Dify 服务可用性

### 实施步骤

#### 1. 在 Dify 中创建工作流

**节点1：定时触发器**
- 类型：定时触发器
- 执行时间：每天 00:00:05（北京时间）
- 时区：Asia/Shanghai

**节点2：HTTP 请求节点**
- 方法：POST
- URL：`http://203.118.55.60:8088/api/test/delete-old-alerts`（需要先添加这个 API 端点）
- 或直接调用数据库 API（如果有的话）

**节点3：日志/通知（可选）**
- 记录执行结果
- 发送通知

#### 2. 注意事项

- Dify 的定时触发器可能不支持秒级精度
- 需要确保 Dify 服务可以访问到数据库或 API
- 可能需要配置认证

---

## 方案4：DBeaver 手动执行 ⭐

### 说明
DBeaver **本身不支持定时任务**，但可以：

1. **手动执行 SQL**：定期手动运行删除 SQL
2. **使用 DBeaver 的 SQL 脚本功能**：保存 SQL 脚本，需要时执行
3. **配合其他工具**：使用 DBeaver 编写 SQL，然后用 cron 或其他工具定时执行

### 在 DBeaver 中执行的 SQL

```sql
-- 删除旧数据的 SQL（可以直接在 DBeaver 中执行测试）
BEGIN;

-- 删除条件1：昨天 23:35 之前的所有数据
DELETE FROM alerts 
WHERE time < (CURRENT_DATE AT TIME ZONE 'Asia/Shanghai')::timestamp - INTERVAL '25 minutes';

-- 删除条件2：昨天 23:35-00:00 之间，但已处理或已超时的数据
DELETE FROM alerts 
WHERE time >= (CURRENT_DATE AT TIME ZONE 'Asia/Shanghai')::timestamp - INTERVAL '25 minutes'
  AND time < (CURRENT_DATE AT TIME ZONE 'Asia/Shanghai')::timestamp
  AND (timeout_triggered = true OR processed = true);

COMMIT;

-- 查看删除结果
SELECT COUNT(*) as deleted_count FROM alerts;
```

---

## 方案5：Docker 容器内的 Cron ⭐⭐⭐

### 优点
- ✅ 在容器内运行，环境一致
- ✅ 不依赖外部系统

### 缺点
- ⚠️ 需要修改 Dockerfile
- ⚠️ 容器重启需要确保 cron 服务启动

### 实施步骤

#### 1. 修改 Dockerfile，添加 cron

```dockerfile
# 安装 cron
RUN apt-get update && apt-get install -y cron

# 创建 cron 任务文件
COPY crontab /etc/cron.d/delete-alerts
RUN chmod 0644 /etc/cron.d/delete-alerts
RUN crontab /etc/cron.d/delete-alerts

# 启动 cron 服务
CMD cron && uvicorn main:app --host 0.0.0.0 --port 8000 --reload
```

#### 2. 创建 crontab 文件

```
5 0 * * * psql -h postgres -U alert_user -d alert_db -c "DELETE FROM alerts WHERE ..."
```

---

## 方案对比总结

| 方案 | 可靠性 | 实施难度 | 维护成本 | 推荐度 |
|------|--------|----------|----------|--------|
| PostgreSQL pg_cron | ⭐⭐⭐⭐⭐ | 中等 | 低 | ⭐⭐⭐⭐⭐ |
| 系统 Cron | ⭐⭐⭐⭐ | 低 | 低 | ⭐⭐⭐⭐ |
| Dify 定时触发 | ⭐⭐⭐ | 中等 | 中 | ⭐⭐⭐ |
| Docker 容器 Cron | ⭐⭐⭐ | 中等 | 中 | ⭐⭐⭐ |
| DBeaver 手动 | ⭐ | 低 | 高 | ⭐ |

## 推荐方案

**首选：PostgreSQL pg_cron**
- 最可靠，直接在数据库层面执行
- 不受应用重启影响
- 性能最好

**备选：系统级 Cron**
- 如果无法安装 pg_cron，这是最简单的方案
- 需要确保脚本路径和权限正确

## 快速实施建议

如果选择 **pg_cron**，需要：
1. 修改 docker-compose.yml 使用支持 pg_cron 的镜像
2. 在数据库中执行 `CREATE EXTENSION pg_cron;`
3. 创建定时任务

如果选择 **系统 Cron**，需要：
1. 在服务器上创建删除脚本
2. 添加到 crontab
3. 测试执行

